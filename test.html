<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1" id="viewport-id">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<head>
  <style>
    body, html {
      margin: 0;
      padding: 0;
    }
    .block {
      position: fixed;
      bottom: 0;
      height: 100px;
      width: 200px;
      background: blue;
    }
  </style>
</head>
<body>
  Ver 7.3
  <p>
    <div style="overflow: scroll; height:160px; background:rgba(0, 0, 0, 0.1);">
      Window Inner, Outer Height: <div id="inner"></div>
    </div>
  </p>
  <p>
    <div style="overflow: scroll; height:100px; background:rgba(0, 0, 0, 0.1);">
      Document Client Height, Offset Height: <div id="client"></div>
    </div>
  </p>
  <p>
    <div style="overflow: scroll; height:100px; background:rgba(0, 0, 0, 0.1);">
      Window Inner, Outer Width: <div id="offset"></div>
    </div>
  </p>
  <p>
    <div style="overflow: scroll; height:100px; background:rgba(0, 0, 0, 0.1);">
      Document Client Width, Offset Width: <div id="clientWidth"></div>
    </div>
  </p>
  <p>
    <div style="overflow: scroll; height:100px; background:rgba(0, 0, 0, 0.1);">
      Screen Width, Height: <div id="screen"></div>
    </div>
  </p>
  <input type="text">
</body>

<script>
  const elements = ['inner', 'client', 'offset', 'clientWidth', 'screen'];
  
  let timerCounter = 0
  const step = 10
  
  const addMeasurements = () => {
   for (const element of elements) {
      const node = document.createElement("div")
      node.innerText = `${Date.now() - window.performance.timing.domContentLoadedEventEnd}ms: `
      switch (element) {
        case 'inner':
          node.innerText += window.innerHeight + ", " + window.outerHeight
          break;
        case 'client':
          node.innerText += document.body.clientHeight + ", " + document.body.offsetHeight
          break;
        case 'offset':
          node.innerText += window.innerWidth + ", " + window.outerWidth
          break;
        case 'clientWidth':
          node.innerText += document.body.clientWidth + ", " + document.body.offsetWidth
          break;
        case 'screen':
          node.innerText += window.screen.width + ", " + window.screen.height
          break;
        default:
          break;
      }
      document.querySelector("#" + element).appendChild(node)
    } 
  }
  const printer = () => {
    timerCounter += step
    addMeasurements()
    if (timerCounter < 1000) {
      setTimeout(printer, step)
    } else {
      timerCounter = 0
    }
  }
  window.addEventListener('resize', () => {
        for (const element of elements) {
            const node = document.createElement("div")
            node.innerText = "RESIZE"
            document.querySelector("#" + element).appendChild(node)
        }
        addMeasurements()
    })
    window.addEventListener('scroll', () => {
        for (const element of elements) {
            const node = document.createElement("div")
            node.innerText = "SCROLL"
            document.querySelector("#" + element).appendChild(node)
        }
    })
    window.addEventListener('load', () => {
        reset()
        for (const element of elements) {
            const node = document.createElement("div")
            node.innerText = "LOAD"
            document.querySelector("#" + element).appendChild(node)
        }
        addMeasurements()
        printer()
    })
    window.addEventListener('orientationchange', () => {
        reset()
        printer()
    })
    window.addEventListener('readystatechange', (event) => {
        for (const element of elements) {
            const node = document.createElement("div")
            node.innerText = `READY STATE: ${document.readyState}`
            document.querySelector("#" + element).appendChild(node)
        }
        addMeasurements()
    })
  
  const reset = () => {
    for (const element of elements) {
      const ele = document.querySelector("#" + element)
      while (ele.children.length) {
        ele.removeChild(ele.children[0])
      }
    }
    timerCounter = 0
  }
  
  const safariVersion = document.createElement("div")
  document.body.appendChild(safariVersion)
  safariVersion.innerText += "Safari Version: "
    
  const userAgent = document.createElement("div")
  userAgent.innerText = navigator.userAgent
  document.body.appendChild(userAgent)
  
  const safariStr = navigator.userAgent.split("Version/")[1]
  if (safariStr) {
    const major = safariStr.split(".")[0]
    const minor = safariStr.split(".")[1]
    const version = safariStr.split(".")[2]
    safariVersion.innerText += " " + major + '.' + minor
  }
  
  document.body.addEventListener("touchstart", () => {
    console.log("TOUCH START")
  })
  document.body.addEventListener("touchmove", () => {
    console.log("TOUCH MOVE")
  })
  document.body.addEventListener("click", () => {
    console.log("ON CLICK")
  })
  
  /*
  const forceReflow = () => {
    const input = document.createElement("input")
    document.body.appendChild(input)
    input.focus()
    input.blur()
    document.body.removeChild(input)
    window.removeEventListener("touchstart", forceReflow)
  }
  window.addEventListener("touchstart", forceReflow)
  */
</script>
<script src="code.js"></script>
</html>
